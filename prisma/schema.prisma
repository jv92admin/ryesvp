// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Venue - physical location where events happen
model Venue {
  id         String   @id @default(uuid())
  name       String
  slug       String   @unique // e.g., "moody-center", "paramount-theatre"
  websiteUrl String?
  address    String?
  city       String   @default("Austin")
  state      String   @default("TX")
  lat        Float?
  lng        Float?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  events Event[]

  @@index([slug])
}

// Event - a specific show/performance at a venue
model Event {
  id            String      @id @default(uuid())
  venueId       String
  venue         Venue       @relation(fields: [venueId], references: [id])
  title         String
  description   String?
  startDateTime DateTime
  endDateTime   DateTime?
  url           String?     // Link to tickets/info
  imageUrl      String?
  source        EventSource @default(VENUE_WEBSITE)
  sourceEventId String?     // External ID from source (for dedup)
  status        EventStatus @default(SCHEDULED)
  category      EventCategory @default(OTHER)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  userEvents UserEvent[]
  enrichment Enrichment?

  @@unique([source, sourceEventId]) // Dedup by source + external ID
  @@index([venueId])
  @@index([startDateTime])
  @@index([status])
  @@index([category])
}

// Enrichment - data gathered from external APIs (Knowledge Graph, Spotify)
model Enrichment {
  id            String   @id @default(uuid())
  eventId       String   @unique
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Search metadata
  searchQuery   String   // What we searched for
  
  // Knowledge Graph data
  kgEntityId    String?  // Knowledge Graph entity ID
  kgName        String?  // Canonical name
  kgDescription String?  // Short description
  kgBio         String?  // Longer bio (Text field)
  kgImageUrl    String?
  kgWikiUrl     String?
  kgTypes       String[] // Array of @type values
  kgScore       Float?   // Result score (confidence)
  
  // Spotify data
  spotifyId         String?  // Spotify artist ID
  spotifyName       String?  // Artist name from Spotify
  spotifyUrl        String?  // Link to Spotify profile
  spotifyGenres     String[] // Array of genres
  spotifyPopularity Int?     // 0-100 popularity score
  spotifyImageUrl   String?
  
  // LLM-generated data
  llmCategory     EventCategory? // Category from LLM
  llmPerformer    String?        // Performer name extracted by LLM
  llmDescription  String?        // Description generated by LLM
  llmConfidence   String?        // high, medium, low
  
  // Ticketmaster data
  tmEventId         String?   // TM event ID (for direct linking)
  tmEventName       String?   // Full TM event name (often more descriptive than venue title)
  tmUrl             String?   // Direct TM purchase URL
  tmPriceMin        Float?    // Min ticket price
  tmPriceMax        Float?    // Max ticket price (often VIP/platinum)
  tmPriceCurrency   String?   // e.g., "USD"
  tmOnSaleStart     DateTime? // When tickets went/go on sale
  tmOnSaleEnd       DateTime? // When ticket sales end
  tmPresales        Json?     // Array of presale windows [{name, startDateTime, endDateTime}]
  tmImageUrl        String?   // High-quality TM image
  tmAttractionId    String?   // TM artist/attraction ID
  tmAttractionName  String?   // Canonical artist name from TM
  tmGenre           String?   // e.g., "Rock", "Hip-Hop/Rap"
  tmSubGenre        String?   // e.g., "Alternative Rock"
  tmSegment         String?   // e.g., "Music", "Sports", "Arts & Theatre"
  tmSupportingActs  String[]  // Openers/supporting acts
  tmExternalLinks   Json?     // { spotify, youtube, instagram, homepage }
  tmMatchConfidence Float?    // 0-1 confidence in the match
  tmPreferTitle     Boolean   @default(false) // LLM recommends using TM title
  tmLastChecked     DateTime? // When we last queried TM for this event
  
  // Inferred data (legacy - from KG/Spotify)
  inferredCategory EventCategory? // Category we think it should be
  categoryUpdated  Boolean @default(false) // Did we update the event category?
  
  // Meta
  status        EnrichmentStatus @default(PENDING)
  retryCount    Int      @default(0)
  errorMessage  String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([status])
  @@index([kgEntityId])
  @@index([spotifyId])
}

enum EnrichmentStatus {
  PENDING     // Not yet processed
  PROCESSING  // Currently being enriched
  COMPLETED   // Successfully enriched
  PARTIAL     // Some sources worked, others didn't
  FAILED      // All sources failed
  SKIPPED     // Intentionally skipped (e.g., no keywords)
}

// User - synced from Supabase Auth
model User {
  id             String   @id @default(uuid())
  authProviderId String   @unique // Supabase Auth user ID
  email          String   @unique
  displayName    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userEvents             UserEvent[]
  
  // Friends
  sentFriendRequests     Friendship[] @relation("SentFriendRequests")
  receivedFriendRequests Friendship[] @relation("ReceivedFriendRequests")
  
  // Lists & Communities
  ownedLists             List[] @relation("OwnedLists")
  listMemberships        ListMember[]
  sentListInvitations    ListMember[] @relation("ListInvitations")
  
  // Invites
  inviteCode             InviteCode?
  inviteRedemption       InviteRedemption?  // How this user was referred

  @@index([authProviderId])
}

// Friendship - mutual relationships between users
model Friendship {
  id          String           @id @default(uuid())
  requesterId String           // User who sent the request
  addresseeId String           // User who received the request
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  requester User @relation("SentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("ReceivedFriendRequests", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@unique([requesterId, addresseeId])
  @@index([requesterId])
  @@index([addresseeId])
  @@index([status])
}

// UserEvent - tracks user's relationship to an event (going/interested)
model UserEvent {
  id        String          @id @default(uuid())
  userId    String
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId   String
  event     Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  status    AttendanceStatus
  comment   String?         // e.g., "Section 105, Row F"
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@unique([userId, eventId]) // One status per user per event
  @@index([userId])
  @@index([eventId])
}

// Enums
enum EventSource {
  VENUE_WEBSITE
  TICKETMASTER
  SEATGEEK
  MANUAL
}

enum EventStatus {
  SCHEDULED
  CANCELLED
  POSTPONED
  SOLD_OUT
}

enum EventCategory {
  CONCERT
  COMEDY
  THEATER
  MOVIE
  SPORTS
  FESTIVAL
  OTHER
}

enum AttendanceStatus {
  GOING
  INTERESTED
  NOT_GOING
}

enum FriendshipStatus {
  PENDING   // Request sent, awaiting acceptance
  ACCEPTED  // Mutual friendship
  DECLINED  // Request declined (can re-request later)
  BLOCKED   // User blocked (cannot interact)
}

// List - Private lists for organizing friends, or public communities
model List {
  id          String   @id @default(uuid())
  name        String
  description String?
  ownerId     String
  isPublic    Boolean  @default(false) // false = private list, true = community
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner   User         @relation("OwnedLists", fields: [ownerId], references: [id], onDelete: Cascade)
  members ListMember[]

  @@index([ownerId])
  @@index([isPublic])
}

// ListMember - membership in a list or community
model ListMember {
  id          String           @id @default(uuid())
  listId      String
  userId      String
  status      ListMemberStatus @default(ACTIVE) // For private lists, always ACTIVE
  role        ListRole         @default(MEMBER)
  invitedById String?          // Who invited this user (for communities)
  isVisible   Boolean          @default(true) // Reciprocity toggle (communities only)
  joinedAt    DateTime         @default(now())

  list      List  @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitedBy User? @relation("ListInvitations", fields: [invitedById], references: [id])

  @@unique([listId, userId])
  @@index([listId])
  @@index([userId])
  @@index([status])
}

enum ListMemberStatus {
  PENDING  // Invitation sent (communities only)
  ACTIVE   // Active member
  DECLINED // Declined invitation
  LEFT     // Left the community
}

enum ListRole {
  OWNER  // Can delete list, manage all members
  ADMIN  // Can manage members (future)
  MEMBER // Regular member
}

// InviteCode - one per user, used for referral links
model InviteCode {
  id          String   @id @default(uuid())
  code        String   @unique  // Short code, e.g. "abc123"
  userId      String   @unique  // One code per user
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  usedCount   Int      @default(0)
  createdAt   DateTime @default(now())
  
  redemptions InviteRedemption[]
  
  @@index([code])
}

// InviteRedemption - tracks who signed up via which invite
model InviteRedemption {
  id           String     @id @default(uuid())
  inviteCodeId String
  inviteCode   InviteCode @relation(fields: [inviteCodeId], references: [id], onDelete: Cascade)
  newUserId    String     @unique  // Each user can only be referred once
  newUser      User       @relation(fields: [newUserId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())
  
  @@index([inviteCodeId])
}

// TMEventCache - Cached Ticketmaster events for offline matching
// Downloaded in batch daily, used to enrich our events without per-event API calls
model TMEventCache {
  id              String    @id // TM event ID (from TM API)
  venueSlug       String    // Our venue slug for easy filtering
  tmVenueId       String    // TM's venue ID
  name            String    // TM event title
  localDate       String?   // Just the date YYYY-MM-DD for easy matching (no timezone issues)
  startDateTime   DateTime  // Event start (full datetime)
  endDateTime     DateTime? // Event end (if available)
  url             String?   // TM purchase URL
  priceMin        Float?    // Min ticket price
  priceMax        Float?    // Max ticket price
  priceCurrency   String?   // e.g., "USD"
  onSaleStart     DateTime? // Public on-sale start
  onSaleEnd       DateTime? // Public on-sale end
  presales        Json?     // Array of presale windows
  imageUrl        String?   // Best image URL
  attractionId    String?   // Main artist/team TM ID
  attractionName  String?   // Main artist/team name
  genre           String?   // e.g., "Rock", "Sports"
  subGenre        String?   // e.g., "Alternative Rock"
  segment         String?   // e.g., "Music", "Sports"
  supportingActs  String[]  // Opener names
  externalLinks   Json?     // { spotify, youtube, etc. }
  
  // Additional useful fields
  status          String?   // "onsale", "offsale", "cancelled", "postponed", "rescheduled"
  seatmapUrl      String?   // Link to seat map image
  pleaseNote      String?   // Important notes (age restrictions, etc.)
  info            String?   // Additional event info
  
  fetchedAt       DateTime  @default(now()) // When we downloaded this
  
  @@index([venueSlug, localDate]) // Primary lookup: venue + date
  @@index([tmVenueId])
  @@index([fetchedAt])
}
