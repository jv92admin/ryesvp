// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Venue - physical location where events happen
model Venue {
  id         String   @id @default(uuid())
  name       String
  slug       String   @unique // e.g., "moody-center", "paramount-theatre"
  websiteUrl String?
  address    String?
  city       String   @default("Austin")
  state      String   @default("TX")
  lat        Float?
  lng        Float?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  events Event[]

  @@index([slug])
}

// Event - a specific show/performance at a venue
model Event {
  id            String      @id @default(uuid())
  venueId       String
  venue         Venue       @relation(fields: [venueId], references: [id])
  title         String
  description   String?
  startDateTime DateTime
  endDateTime   DateTime?
  url           String?     // Link to tickets/info
  imageUrl      String?
  source        EventSource @default(VENUE_WEBSITE)
  sourceEventId String?     // External ID from source (for dedup)
  status        EventStatus @default(SCHEDULED)
  category      EventCategory @default(OTHER)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  userEvents UserEvent[]
  enrichment Enrichment?
  squads     Squad[]

  @@unique([source, sourceEventId]) // Dedup by source + external ID
  @@index([venueId])
  @@index([startDateTime])
  @@index([status])
  @@index([category])
}

// Enrichment - data gathered from external APIs (Knowledge Graph, Spotify)
model Enrichment {
  id            String   @id @default(uuid())
  eventId       String   @unique
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Search metadata
  searchQuery   String   // What we searched for
  
  // Knowledge Graph data
  kgEntityId    String?  // Knowledge Graph entity ID
  kgName        String?  // Canonical name
  kgDescription String?  // Short description
  kgBio         String?  // Longer bio (Text field)
  kgImageUrl    String?
  kgWikiUrl     String?
  kgTypes       String[] // Array of @type values
  kgScore       Float?   // Result score (confidence)
  
  // Spotify data
  spotifyId         String?  // Spotify artist ID
  spotifyName       String?  // Artist name from Spotify
  spotifyUrl        String?  // Link to Spotify profile
  spotifyGenres     String[] // Array of genres
  spotifyPopularity Int?     // 0-100 popularity score
  spotifyImageUrl   String?
  
  // LLM-generated data
  llmCategory     EventCategory? // Category from LLM
  llmPerformer    String?        // Performer name extracted by LLM
  llmDescription  String?        // Description generated by LLM
  llmConfidence   String?        // high, medium, low
  
  // Ticketmaster data (from Discovery API)
  tmEventId         String?   // TM event ID
  tmEventName       String?   // TM event name (often more descriptive)
  tmUrl             String?   // TM page URL (main value!)
  
  // TM Sales dates
  tmOnSaleStart     DateTime? // When tickets go on sale
  tmOnSaleEnd       DateTime? // When ticket sales end
  tmPresales        Json?     // Presale windows
  
  // TM Images
  tmImageUrl        String?   // TM image
  tmSeatmapUrl      String?   // Seat map image
  
  // TM Artist info
  tmAttractionId    String?   // TM artist/attraction ID  
  tmAttractionName  String?   // Artist name from TM
  tmSupportingActs  String[]  // Openers/supporting acts
  tmExternalLinks   Json?     // { spotify, youtube, etc. }
  
  // TM Classification
  tmGenre           String?   // e.g., "Rock"
  tmSubGenre        String?   // e.g., "Alternative Rock"
  tmSegment         String?   // e.g., "Music", "Sports"
  
  // TM Event details
  tmInfo            String?   // Additional event info
  tmPleaseNote      String?   // Important notes
  tmTicketLimit     Int?      // Max tickets per order
  tmTimezone        String?   // Event timezone
  
  // TM Promoter
  tmPromoterId      String?
  tmPromoterName    String?
  
  // TM Status & matching
  tmStatus          String?   // "onsale", "offsale", etc.
  tmMatchConfidence Float?    // 0-1 confidence in the match
  tmPreferTitle     Boolean   @default(false) // Use TM title instead of venue title
  tmLastChecked     DateTime? // When we last checked TM
  
  // Inferred data (legacy - from KG/Spotify)
  inferredCategory EventCategory? // Category we think it should be
  categoryUpdated  Boolean @default(false) // Did we update the event category?
  
  // Meta
  status        EnrichmentStatus @default(PENDING)
  retryCount    Int      @default(0)
  errorMessage  String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([status])
  @@index([kgEntityId])
  @@index([spotifyId])
}

enum EnrichmentStatus {
  PENDING     // Not yet processed
  PROCESSING  // Currently being enriched
  COMPLETED   // Successfully enriched
  PARTIAL     // Some sources worked, others didn't
  FAILED      // All sources failed
  SKIPPED     // Intentionally skipped (e.g., no keywords)
}

// User - synced from Supabase Auth
model User {
  id             String   @id @default(uuid())
  authProviderId String   @unique // Supabase Auth user ID
  email          String   @unique
  displayName    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userEvents             UserEvent[]
  
  // Friends
  sentFriendRequests     Friendship[] @relation("SentFriendRequests")
  receivedFriendRequests Friendship[] @relation("ReceivedFriendRequests")
  
  // Lists & Communities
  ownedLists             List[] @relation("OwnedLists")
  listMemberships        ListMember[]
  sentListInvitations    ListMember[] @relation("ListInvitations")
  
  // Invites
  inviteCode             InviteCode?
  inviteRedemption       InviteRedemption?  // How this user was referred
  
  // Squads
  squadsCreated          Squad[]       @relation("SquadCreator")
  squadMembers           SquadMember[]
  membersCovered         SquadMember[] @relation("CoveredByUser")
  priceGuidesAdded       SquadPriceGuide[]
  stopsAdded             SquadStop[]
  
  // Notifications
  notifications          Notification[]

  @@index([authProviderId])
}

// Friendship - mutual relationships between users
model Friendship {
  id          String           @id @default(uuid())
  requesterId String           // User who sent the request
  addresseeId String           // User who received the request
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  requester User @relation("SentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("ReceivedFriendRequests", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@unique([requesterId, addresseeId])
  @@index([requesterId])
  @@index([addresseeId])
  @@index([status])
}

// UserEvent - tracks user's relationship to an event (going/interested)
model UserEvent {
  id        String          @id @default(uuid())
  userId    String
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId   String
  event     Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  status    AttendanceStatus
  comment   String?         // e.g., "Section 105, Row F"
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@unique([userId, eventId]) // One status per user per event
  @@index([userId])
  @@index([eventId])
}

// Enums
enum EventSource {
  VENUE_WEBSITE
  TICKETMASTER
  SEATGEEK
  MANUAL
}

enum EventStatus {
  SCHEDULED
  CANCELLED
  POSTPONED
  SOLD_OUT
}

enum EventCategory {
  CONCERT
  COMEDY
  THEATER
  MOVIE
  SPORTS
  FESTIVAL
  OTHER
}

enum AttendanceStatus {
  INTERESTED      // On my radar, maybe
  GOING           // Committed, have ticket or will get one
  NEED_TICKETS    // Actively looking for tickets
  HAVE_TICKETS    // Have extras to share/sell
  NOT_GOING       // Explicitly not going
}

enum FriendshipStatus {
  PENDING   // Request sent, awaiting acceptance
  ACCEPTED  // Mutual friendship
  DECLINED  // Request declined (can re-request later)
  BLOCKED   // User blocked (cannot interact)
}

// List - Private lists for organizing friends, or public communities
model List {
  id          String   @id @default(uuid())
  name        String
  description String?
  ownerId     String
  isPublic    Boolean  @default(false) // false = private list, true = community
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner   User         @relation("OwnedLists", fields: [ownerId], references: [id], onDelete: Cascade)
  members ListMember[]

  @@index([ownerId])
  @@index([isPublic])
}

// ListMember - membership in a list or community
model ListMember {
  id          String           @id @default(uuid())
  listId      String
  userId      String
  status      ListMemberStatus @default(ACTIVE) // For private lists, always ACTIVE
  role        ListRole         @default(MEMBER)
  invitedById String?          // Who invited this user (for communities)
  isVisible   Boolean          @default(true) // Reciprocity toggle (communities only)
  joinedAt    DateTime         @default(now())

  list      List  @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitedBy User? @relation("ListInvitations", fields: [invitedById], references: [id])

  @@unique([listId, userId])
  @@index([listId])
  @@index([userId])
  @@index([status])
}

enum ListMemberStatus {
  PENDING  // Invitation sent (communities only)
  ACTIVE   // Active member
  DECLINED // Declined invitation
  LEFT     // Left the community
}

enum ListRole {
  OWNER  // Can delete list, manage all members
  ADMIN  // Can manage members (future)
  MEMBER // Regular member
}

// InviteCode - one per user, used for referral links
model InviteCode {
  id          String   @id @default(uuid())
  code        String   @unique  // Short code, e.g. "abc123"
  userId      String   @unique  // One code per user
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  usedCount   Int      @default(0)
  createdAt   DateTime @default(now())
  
  redemptions InviteRedemption[]
  
  @@index([code])
}

// InviteRedemption - tracks who signed up via which invite
model InviteRedemption {
  id           String     @id @default(uuid())
  inviteCodeId String
  inviteCode   InviteCode @relation(fields: [inviteCodeId], references: [id], onDelete: Cascade)
  newUserId    String     @unique  // Each user can only be referred once
  newUser      User       @relation(fields: [newUserId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())
  
  @@index([inviteCodeId])
}

// TMEventCache - Cached Ticketmaster events for offline matching
// Downloaded in batch daily, used to enrich our events without per-event API calls
// NOTE: Only stores fields reliably available from TM Discovery API (free tier)
model TMEventCache {
  id              String    @id // TM event ID
  venueSlug       String    // Our venue slug for filtering
  tmVenueId       String    // TM's venue ID
  name            String    // Event title
  url             String?   // TM page URL (main value!)
  
  // Dates
  localDate       String?   // YYYY-MM-DD for matching
  startDateTime   DateTime  // Event start
  endDateTime     DateTime? // Event end (if available)
  timezone        String?   // Event timezone
  spanMultipleDays Boolean @default(false)
  
  // Sales dates (usually available)
  onSaleStart     DateTime? // Public on-sale start
  onSaleEnd       DateTime? // Public on-sale end
  presales        Json?     // Presale windows
  
  // Images
  imageUrl        String?   // Best image URL
  seatmapUrl      String?   // Seat map image
  
  // Artist/attraction
  attractionId    String?   // Main artist/team TM ID
  attractionName  String?   // Main artist/team name
  supportingActs  String[]  // Opener names
  externalLinks   Json?     // { spotify, youtube, etc. }
  
  // Classification
  genre           String?   // e.g., "Rock", "Sports"
  subGenre        String?   // e.g., "Alternative Rock"
  segment         String?   // e.g., "Music", "Sports"
  
  // Promoter
  promoterId      String?
  promoterName    String?
  
  // Status & notes
  status          String?   // "onsale", "offsale", "cancelled", etc.
  info            String?   // Additional event info
  pleaseNote      String?   // Important notes
  ticketLimit     Int?      // Max tickets per order
  
  fetchedAt       DateTime  @default(now())
  
  @@index([venueSlug, localDate])
  @@index([tmVenueId])
  @@index([fetchedAt])
}

// Squad - A planning room for one event with a group of friends
model Squad {
  id          String   @id @default(uuid())
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  createdById String
  createdBy   User     @relation("SquadCreator", fields: [createdById], references: [id])
  
  // Logistics (deferred to Day-of mode)
  meetTime    DateTime?
  meetSpot    String?
  deadline    DateTime?  // For ticket purchase deadline
  playlistUrl String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  members     SquadMember[]
  priceGuides SquadPriceGuide[]
  stops       SquadStop[]
  
  @@index([eventId])
  @@index([createdById])
}

model SquadMember {
  id             String   @id @default(uuid())
  squadId        String
  squad          Squad    @relation(fields: [squadId], references: [id], onDelete: Cascade)
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Attendance status within squad
  status         SquadMemberStatus @default(THINKING)
  
  // Guests (+1, +2, etc. - non-squad members you're bringing)
  guestCount     Int      @default(0)
  
  // Ticket status
  ticketStatus   SquadTicketStatus @default(MAYBE)
  coveredById    String?  // If COVERED, who is buying their ticket
  coveredBy      User?    @relation("CoveredByUser", fields: [coveredById], references: [id])
  buyingForIds   String[] // Array of user IDs this member is buying tickets for
  
  isOrganizer    Boolean  @default(false)
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  @@unique([squadId, userId])  // One membership per user per squad
  @@index([userId])
  @@index([coveredById])
}

// Squad-level ticket price guide (replaces per-person budget)
model SquadPriceGuide {
  id        String   @id @default(uuid())
  squadId   String
  squad     Squad    @relation(fields: [squadId], references: [id], onDelete: Cascade)
  
  label     String?  // "GA", "Balcony", "Section 108", etc.
  priceMin  Int      // Minimum price seen
  priceMax  Int?     // Maximum price (null if single price)
  source    String?  // "Ticketmaster", "Venue site", etc.
  
  addedById String
  addedBy   User     @relation(fields: [addedById], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([squadId])
}

// Squad Stop - An itinerary item for Day-of mode
model SquadStop {
  id          String    @id @default(uuid())
  squadId     String
  squad       Squad     @relation(fields: [squadId], references: [id], onDelete: Cascade)
  
  label       String    // "Pre-drinks", "Concert", "After-party"
  time        DateTime? // When this stop happens
  location    String?   // Venue name or address
  notes       String?   // Additional info about this stop
  sortOrder   Int       // For ordering stops in the itinerary
  
  addedById   String
  addedBy     User      @relation(fields: [addedById], references: [id])
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([squadId])
  @@index([addedById])
}

enum SquadMemberStatus {
  THINKING  // Maybe
  IN        // Yes, going
  OUT       // Not going
}

enum SquadTicketStatus {
  YES      // Has/will get own ticket
  MAYBE    // Open to getting one, not committed
  NO       // Not planning to get a ticket
  COVERED  // Someone else is buying their ticket
}

// Weather cache - store weather data by location + date
model WeatherCache {
  id              String   @id @default(uuid())
  
  // Location (rounded to ~1km precision for cache efficiency)
  lat             Float
  lng             Float
  
  // Date this forecast is for (YYYY-MM-DD)
  forecastDate    String
  
  // Weather data (imperial units)
  tempHigh        Int      // Fahrenheit
  tempLow         Int
  feelsLikeHigh   Int
  feelsLikeLow    Int
  precipChance    Int      // Percentage
  humidity        Int      // Percentage
  uvIndex         Int
  windSpeed       Int      // MPH
  condition       String   // "Sunny", "Cloudy", "Rain", etc.
  conditionIcon   String   // Icon URL from Google
  
  // Metadata
  fetchedAt       DateTime @default(now())
  
  // Unique constraint: one cache entry per location + date
  @@unique([lat, lng, forecastDate])
  @@index([forecastDate])
}

// Notification - In-app notifications for user actions
model Notification {
  id            String           @id @default(uuid())
  recipientId   String
  recipient     User             @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  type          NotificationType
  
  // Flexible payload for different notification types
  // Contains: actorId, actorName, squadId, eventId, eventTitle, eventDate, etc.
  payload       Json
  
  createdAt     DateTime         @default(now())
  readAt        DateTime?
  
  @@index([recipientId, createdAt])
  @@index([recipientId, readAt])
}

enum NotificationType {
  // Friend graph
  FRIEND_REQUEST_RECEIVED  // Someone sent you a friend request
  FRIEND_REQUEST_ACCEPTED  // Your friend request was accepted
  
  // Plan lifecycle
  ADDED_TO_PLAN            // You were added to a plan
  PLAN_CANCELLED           // A plan you're in was cancelled
  PLAN_MEMBER_JOINED       // Someone joined your plan (host only)
  PLAN_MEMBER_LEFT         // Someone left your plan (host only)
  
  // Tickets
  TICKET_COVERED_FOR_YOU   // Someone is covering your ticket
  
  // Plan details
  PLAN_MEETUP_CREATED      // Meetup time/location set for a plan
}